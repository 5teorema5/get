<h1>Библиотека NumPy</h1>

`import numpy as np`
np.array([[ a, b, c],
          [ d, e, f]]) - две оси: первая имеет длину 2, вторая имеет длину 3.
          
a = np.arange(number).reshape(m, n) - массив mхn с числами 0, ..., number

Параметры:
- `print(a.shape)` - размер массива
- `print(a.ndim)` - колличество осей
- `print(a.size)` - колличество элементов

m = np.array([(a, b, c), (d, e, f)]) - преобразование последовательности последовательностей в двумерный массив

Обращение к элементам:
- `print(m[x][y])`
- `print(m[x, y])`
- `print(m[x][[y1, y2]])` - выбор сразу нескольких элементов

Базовые массивы:
- `np.zeros((a, b))` - массив из нулей
- `np.ones(a, b)` - массив из единиц
- `np.eye(a)` - единичная матрица
- `print(np.diag(np.array([1, 2, 3, 4]), 2))` - матрица 6х6, смещнная диагональ

Заполнение:
- `np.empty((a, b))` - заполнение случайными элементами (состояние памяти)
- `np.random.randint(max, size=(a,b))` - заполнение случайными элементами из диапазоне
- `np.arange(a, b, step)` - создание последовательности чисел с равным шагом
- `np.linspace(a, b, num)` - создание последовательности с заданным колличеством элементов

Если массив достаточно большой, то в консоли будет выводиться только часть элементов. Для того, чтобы вывести все элементы, пользуемся конструкцией:
```
import sys
np.set_printoptions(threshold=sys.maxsize)
np.arange(10000).reshape(100,100)
```

Арифметические операции с массивами применяются поэлементно. В их результате создается новый массив и заполняется результатом. Однако, некоторые операции, такие как += и *=, изменяют существующий массив вместо того, чтобы создавать новый. Оператор произведения * тоже работает поэлементно в массивах NumPy.
- `print(a - b)`
- `print(b ** 2)`
- `print(10 * a)`
- `print(a < 35)` - возвращает массив булевых значений
- `print(c * d)` - умножение матриц поэлементарно
- `print(c @ d)` - умножение матриц строка на столбец
- `print(a.dot(b))` - другой вид записи матричного умножения
- `print(np.dot(a, b))` - другой вид записи матричного умножения

Многие унарные операции, такие как вычисление суммы всех элементов в массиве, реализованы как методы класса ndarray:
- `print(a.sum())`
- `print(a.min())`
- `print(a.max())`

Однако, указав параметр оси, вы можете применить операцию вдоль указанной оси массива:
- `print(b)`
- `print(b.sum(axis=0))` - сумма каждого столбца
- `print(b.min(axis=1))` - минимум каждой строки
- `print(b.cumsum(axis=1))` - кумулятивная сумма вдоль каждой строки

NumPy предоставляет знакомые математические функции, такие как `sin`, `cos` и `exp`.
Функция `any` возвращает True, если хотя бы один элемент в numpy-массиве удовлетворяет условию (квантор существования (∃)).
Функция `all` возвращает True, только если все элементы в numpy-массиве удовлетворяет условию (квантор всеобщности (∀)).

Одномерные массивы можно индексировать, нарезать и итерировать, как встроенные типы последовательностей Python (например, списки):
- `a[a:b:step] = tmp` - от a до b с шагом step будут заменяться элементы на tmp

Многомерные массивы могут иметь по одному индексу для каждой оси. Эти индексы даются в виде кортежа через запятую:
- `print(np.fromfunction(lambda i, j: i, (2, 2)), '\n')`
- `print(np.fromfunction(lambda i, j: j, (2, 2)), '\n')`
- `b = np.fromfunction(f, (a, b))` - задание массива axb, элементы задаёт функция f
- `print(b[x, y])` - элемент x-ой строки, y-ого столбца
- `print(b[x1:x2, y])`
- `print(b[a])` - полный срез, вывод строки a

Итерация по многомерным массивам выполняется относительно первой оси (вывод матрицы):
```
for row in b:
     print(row)
```
Однако, если вы хотите выполнить операцию с каждым элементом в массиве, можно использовать атрибут `flat`, который позволяет итерировать по всем элементам массива (вывод всех элементов):
```
for element in b.flat:
     print(element)
```

Некоторые функции:
- `print(a.ravel())` - возвращает сглаженный массив (flattened) (фактически список)
- `print(a.reshape(6, 2))` - возвращает массив с измененной формой (возвращает свой аргумент)
- `a.resize((2, 6))` - возвращает массив с измененной формой (изменяет сам массив)
- `print(a.T)` - возвращает транспонированный массив
- `np.fliplr(a)` - отражение матрицы относительно побочной диагонали
- `np.fill_diagonal(a, [b1, b1, .., bn])` - замена элементов на диагонали
- `print(np.vstack((a, b)))` - объединение массивов в высоту
- `print(np.hstack((a, b)))` - объединение массивов в ширину
- `print(np.vstack((a, b)))` - складывает массивы как строки матрицы
- `print(np.row_stack((a, b)))` - складывает массивы как строки матрицы
- `print(np.hstack((a, b)))` - складывает массивы в сглаженную матрицу
- `print(np.column_stack((a, b)))` - складывает массивы как столбцы матрицы
- `np.linalg.inv(mat)` - вычисление обратной матрицы
